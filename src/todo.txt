Todo:

-> Generate Permutations                                [o]
-> Reduce Permutations                                  [o]
-> Label Permutations                                   [o]
-> Store permutation - label                            [z]
    * Is this needed ?
    - Not really, let's proceed
-> Do pre-computation                                   [ ]
-> Create a pure permutation labels
    + generator                                         [o]
    + storage                                           [o]
    + retrieval                                         [o]

-> Construct struct and graph           [ ]



Complexity problems:

-> get_code_by_moving_block (code, i, j, k)
    : Need to do in O(1) complexity, but how?
    : Need to be done in a very efficient serialized manner?

    : Precomputation:
        Suppose for [code][i][j] (code and block)
            -> We store min (code) which leads to optimal answer for all k
            to which we can tranpose this block
            -> If found use the value,
            -> If not found, calculate for all
        -> Will reduce complexity to O(n!*(n) + n!*n^2)

        -> This will require another level of abstraction